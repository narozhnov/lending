{"version":3,"sources":["documentParser.js"],"names":[],"mappings":";;;;;;;;;;AACA;;AACA;;AACA;;;;;;;;;AAKA,IAAM,iBAAiB,SAAjB,cAAiB,UAAW;AAChC,qCAAW,OAAX,CAAmB,eAAO;AACxB,QAAM,QAAQ,IAAI,MAAJ,OAAe,4BAAwB,SAAvC,EAA+C,IAA/C,CAAR,CADkB;AAExB,cAAU,QAAQ,OAAR,CAAgB,KAAhB,QAA2B,mCAA8B,SAAzD,CAAV,CAFwB;GAAP,CAAnB,CADgC;;AAMhC,SAAO,OAAP,CANgC;CAAX;;;;;AAYvB,IAAM,oBAAoB,SAApB,iBAAoB,OAAQ;AAChC,MAAI,CAAC,IAAD,EAAO;AACT,UAAM,4BAAqB,yCAArB,CAAN,CADS;GAAX;;AAIA,MAAM,UAAU,KAAK,OAAL,CAAa,WAAb,EAAV,CAL0B;AAMhC,MAAM,aAAa,cAAI,aAAJ,CAAkB,IAAlB,CAAb,CAN0B;;AAQhC,MAAM,UAAU,EAAE,gBAAF,EAAW,sBAAX,EAAV,CAR0B;;AAUhC,MAAI,mCAAW,OAAX,CAAmB,OAAnB,MAAgC,CAAC,CAAD,EAAI;AACtC,QAAM,IAAI,cAAI,QAAJ,CAAa,IAAb,CAAJ,CADgC;AAEtC,YAAQ,OAAR,GAAkB,EAAE,OAAF,EAAW,IAAX,GAAkB,IAAlB,EAAlB,CAFsC;GAAxC,MAGO;AACL,QAAM,WAAW,cAAI,WAAJ,CAAgB,IAAhB,CAAX,CADD;AAEL,YAAQ,QAAR,GAAmB,WAAW,sBAAS,QAAT,EAAmB;aAAS,MAAM,OAAN;KAAT,CAAnB,CAA2C,GAA3C,CAA+C,iBAA/C,CAAX,GAA+E,EAA/E,CAFd;GAHP;;AAQA,SAAO,OAAP,CAlBgC;CAAR;;;;;;;;AA2B1B,IAAM,iBAAiB,SAAjB,cAAiB,UAAW;AAChC,MAAI,aAAJ,CADgC;;AAGhC,MAAI;AACF,QAAM,IAAI,cAAI,QAAJ,CAAa,eAAe,OAAf,CAAb,CAAJ,CADJ;AAEF,WAAO,EAAE,SAAF,CAAP,CAFE;GAAJ,CAGE,OAAO,CAAP,EAAU;AACV,UAAM,sBAAe,8BAAf,CAAN,CADU;GAAV;;AAIF,MAAI,CAAC,IAAD,EAAO;AACT,UAAM,0BAAmB,8BAAnB,CAAN,CADS;GAAX;;AAIA,SAAO,kBAAkB,KAAK,GAAL,CAAS,CAAT,CAAlB,CAAP,CAdgC;CAAX;;kBAiBR","file":"documentParser.js","sourcesContent":["import _ from 'lodash'\nimport { endingTags } from './MJMLElementsCollection'\nimport { ParseError, EmptyMJMLError, NullElementError } from './Error'\nimport dom from './helpers/dom'\n\n/**\n * Avoid htmlparser to parse ending tags\n */\nconst safeEndingTags = content => {\n  endingTags.forEach(tag => {\n    const regex = new RegExp(`<${tag}([^>]*)>([^]*?)<\\/${tag}>`, 'gm')\n    content = content.replace(regex, `<${tag} $1><!--[CDATA[$2]]--></${tag}>`)\n  })\n\n  return content\n}\n\n/**\n * converts MJML body into a JSON representation\n */\nconst mjmlElementParser = elem => {\n  if (!elem) {\n    throw new NullElementError('Null element found in mjmlElementParser')\n  }\n\n  const tagName = elem.tagName.toLowerCase()\n  const attributes = dom.getAttributes(elem)\n\n  const element = { tagName, attributes }\n\n  if (endingTags.indexOf(tagName) !== -1) {\n    const $ = dom.parseXML(elem)\n    element.content = $(tagName).html().trim()\n  } else {\n    const children = dom.getChildren(elem)\n    element.children = children ? _.filter(children, child => child.tagName).map(mjmlElementParser) : []\n  }\n\n  return element\n}\n\n/**\n * Import an html document containing some mjml\n * returns JSON\n *   - container: the mjml container\n *   - mjml: a json representation of the mjml\n */\nconst documentParser = content => {\n  let body\n\n  try {\n    const $ = dom.parseXML(safeEndingTags(content))\n    body = $('mj-body')\n  } catch (e) {\n    throw new ParseError('Error while parsing the file')\n  }\n\n  if (!body) {\n    throw new EmptyMJMLError('No mj-body found in the file')\n  }\n\n  return mjmlElementParser(body.get(0))\n}\n\nexport default documentParser\n"],"sourceRoot":"/source/"}